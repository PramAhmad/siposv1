{"version":3,"file":"index.js","sources":["../dist-transpiled/locationHistory.js","../dist-transpiled/utils.js","../dist-transpiled/router.js","../dist-transpiled/viewStacks.js","../dist-transpiled/index.js"],"sourcesContent":["export const createLocationHistory = () => {\n    const locationHistory = [];\n    const tabsHistory = {};\n    const add = (routeInfo) => {\n        switch (routeInfo.routerAction) {\n            case \"pop\":\n                pop(routeInfo);\n                break;\n            default:\n                addRoute(routeInfo);\n                break;\n        }\n        if (routeInfo.routerDirection === \"root\") {\n            clearHistory();\n            addRoute(routeInfo);\n        }\n    };\n    const update = (routeInfo) => {\n        const locationIndex = locationHistory.findIndex((x) => x.id === routeInfo.id);\n        if (locationIndex > -1) {\n            locationHistory.splice(locationIndex, 1, routeInfo);\n        }\n        const tabArray = tabsHistory[routeInfo.tab || \"\"];\n        if (tabArray) {\n            const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);\n            if (tabIndex > -1) {\n                tabArray.splice(tabIndex, 1, routeInfo);\n            }\n            else {\n                tabArray.push(routeInfo);\n            }\n        }\n        else if (routeInfo.tab) {\n            tabsHistory[routeInfo.tab] = [routeInfo];\n        }\n    };\n    const pop = (routeInfo) => {\n        const tabHistory = getTabsHistory(routeInfo.tab);\n        let ri;\n        if (tabHistory) {\n            // Pop all routes until we are back\n            ri = tabHistory[tabHistory.length - 1];\n            while (ri && ri.id !== routeInfo.id) {\n                tabHistory.pop();\n                ri = tabHistory[tabHistory.length - 1];\n            }\n            // Replace with updated route\n            tabHistory.pop();\n            tabHistory.push(routeInfo);\n        }\n        ri = locationHistory[locationHistory.length - 1];\n        while (ri && ri.id !== routeInfo.id) {\n            locationHistory.pop();\n            ri = locationHistory[locationHistory.length - 1];\n        }\n        // Replace with updated route\n        locationHistory.pop();\n        locationHistory.push(routeInfo);\n    };\n    const addRoute = (routeInfo) => {\n        const tabHistory = getTabsHistory(routeInfo.tab);\n        if (tabHistory) {\n            // If the latest routeInfo is the same (going back and forth between tabs), replace it\n            if (tabHistory[tabHistory.length - 1] &&\n                tabHistory[tabHistory.length - 1].id === routeInfo.id) {\n                tabHistory.pop();\n            }\n            tabHistory.push(routeInfo);\n        }\n        locationHistory.push(routeInfo);\n    };\n    /**\n     * Wipes the location history arrays.\n     * You can optionally provide a routeInfo\n     * object which will wipe that entry\n     * and every entry that appears after it.\n     */\n    const clearHistory = (routeInfo) => {\n        if (routeInfo) {\n            const { position, tab } = routeInfo;\n            /**\n             * If there is no route index in locationHistory\n             * then there will not be any route index in\n             * tabs either.\n             */\n            const existingRouteIndex = locationHistory.findIndex((r) => r.position === position);\n            if (existingRouteIndex === -1)\n                return;\n            locationHistory.splice(existingRouteIndex);\n            const clearTabHistory = (tab) => {\n                const existingTabRouteIndex = tabsHistory[tab].findIndex((r) => r.position === position);\n                if (existingTabRouteIndex === -1)\n                    return;\n                tabsHistory[tab].splice(existingTabRouteIndex);\n            };\n            /**\n             * We also need to search the current tab\n             * to correctly reset the individual tab\n             * stack. We should not clear the entire\n             * tab stack as that means we will lose\n             * a reference to the root tab route.\n             */\n            const tabHistory = tabsHistory[tab];\n            if (tab && tabHistory) {\n                clearTabHistory(tab);\n                /**\n                 * If we are not clearing items after\n                 * a tabs page, it is still possible\n                 * that there are future tabs pages to clear.\n                 * As a result, we need to search through\n                 * all the tab stacks and remove views that appear\n                 * after the given routeInfo.\n                 *\n                 * Example: /non-tabs-page --> /tabs/tab1 --> /non-tabs-page\n                 * (via router.go(-1)) --> /tabs/tab2. The /tabs/tab1 history\n                 * has been overwritten with /tabs/tab2. As a result,\n                 * the /tabs/tab1 route info in the Tab 1 stack should be removed.\n                 */\n            }\n            else {\n                for (const tab in tabsHistory) {\n                    clearTabHistory(tab);\n                }\n            }\n        }\n        else {\n            for (const tab in tabsHistory) {\n                tabsHistory[tab] = [];\n            }\n            locationHistory.length = 0;\n        }\n    };\n    const getTabsHistory = (tab) => {\n        let history;\n        if (tab) {\n            history = tabsHistory[tab];\n            if (!history) {\n                history = tabsHistory[tab] = [];\n            }\n        }\n        return history;\n    };\n    const size = () => locationHistory.length;\n    /**\n     * Finds and returns the location history item\n     * given the state of browser's history API.\n     * This is useful when jumping around in browser\n     * history using router.go.\n     */\n    const current = (initialHistory, currentHistory) => {\n        /**\n         * initialHistory does not always start at 0 if users navigated\n         * to app from another website, so doing this math lets us\n         * find the correct index in our locationHistory array.\n         */\n        const index = currentHistory - initialHistory;\n        return locationHistory[index] || last();\n    };\n    const last = () => locationHistory[locationHistory.length - 1];\n    /**\n     * With the introduction of router.go support, we no longer remove\n     * items from locationHistory as they may be needed again in the future.\n     * As a result, we need to look at the current position in location history\n     * to see if users can navigate back n pages. Previously we were checking\n     * the length of locationHistory, but that only worked since we were pruning\n     * the array.\n     */\n    const canGoBack = (deep = 1, initialHistory, currentHistory) => {\n        return currentHistory - deep >= initialHistory;\n    };\n    const getFirstRouteInfoForTab = (tab) => {\n        const tabHistory = getTabsHistory(tab);\n        if (tabHistory) {\n            return tabHistory[0];\n        }\n        return undefined;\n    };\n    const getCurrentRouteInfoForTab = (tab) => {\n        const tabHistory = getTabsHistory(tab);\n        if (tabHistory) {\n            return tabHistory[tabHistory.length - 1];\n        }\n        return undefined;\n    };\n    /**\n     * Finds and returns the previous view based upon\n     * what originally pushed it (pushedByRoute).\n     * When `delta` < -1 then we should just index into\n     * to array because the previous view that we want is not\n     * necessarily the view that pushed our current view.\n     * Additionally, when jumping around in history, we\n     * do not modify the locationHistory stack so we would\n     * not update pushedByRoute anyways.\n     */\n    const findLastLocation = (routeInfo, delta = -1) => {\n        const routeInfos = getTabsHistory(routeInfo.tab);\n        if (routeInfos) {\n            if (delta < -1) {\n                return routeInfos[routeInfos.length - 1 + delta];\n            }\n            else {\n                for (let i = routeInfos.length - 2; i >= 0; i--) {\n                    const ri = routeInfos[i];\n                    if (ri) {\n                        if (ri.pathname === routeInfo.pushedByRoute) {\n                            return ri;\n                        }\n                    }\n                }\n            }\n        }\n        if (delta < -1) {\n            return locationHistory[locationHistory.length - 1 + delta];\n        }\n        else {\n            for (let i = locationHistory.length - 2; i >= 0; i--) {\n                const ri = locationHistory[i];\n                if (ri) {\n                    if (ri.pathname === routeInfo.pushedByRoute) {\n                        return ri;\n                    }\n                }\n            }\n        }\n        return undefined;\n    };\n    return {\n        current,\n        size,\n        last,\n        add,\n        canGoBack,\n        update,\n        getFirstRouteInfoForTab,\n        getCurrentRouteInfoForTab,\n        findLastLocation,\n        clearHistory,\n    };\n};\n//# sourceMappingURL=locationHistory.js.map","const ids = { main: 0 };\nexport const generateId = (type = \"main\") => {\n    var _a;\n    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n    ids[type] = id;\n    return id.toString();\n};\n//# sourceMappingURL=utils.js.map","import { parseQuery } from \"vue-router\";\nimport { createLocationHistory } from \"./locationHistory\";\nimport { generateId } from \"./utils\";\n// TODO(FW-2969): types\nexport const createIonRouter = (opts, router) => {\n    let currentNavigationInfo = {\n        direction: undefined,\n        action: undefined,\n        delta: undefined,\n    };\n    /**\n     * Ionic Vue should only react to navigation\n     * changes once they have been confirmed and should\n     * never affect the outcome of navigation (with the\n     * exception of going back or selecting a tab).\n     * As a result, we should do our work in afterEach\n     * which is fired once navigation is confirmed\n     * and any user guards have run.\n     */\n    router.afterEach((to, _, failure) => {\n        if (failure)\n            return;\n        const { direction, action, delta } = currentNavigationInfo;\n        /**\n         * When calling router.replace, we are not informed\n         * about the replace action in opts.history.listen\n         * but we can check to see if the latest routing action\n         * was a replace action by looking at the history state.\n         * We need to use opts.history rather than window.history\n         * because window.history will be undefined when using SSR.\n         */\n        currentHistoryPosition = opts.history.state.position;\n        const replaceAction = opts.history.state.replaced ? \"replace\" : undefined;\n        handleHistoryChange(to, action || replaceAction, direction, delta);\n        currentNavigationInfo = {\n            direction: undefined,\n            action: undefined,\n            delta: undefined,\n        };\n    });\n    const locationHistory = createLocationHistory();\n    /**\n     * Keeping track of the history position\n     * allows us to determine if a user is pushing\n     * new pages or updating history via the forward\n     * and back browser buttons.\n     */\n    let initialHistoryPosition = opts.history.state.position;\n    let currentHistoryPosition = opts.history.state.position;\n    let currentRouteInfo;\n    let incomingRouteParams;\n    const historyChangeListeners = [];\n    if (typeof document !== \"undefined\") {\n        document.addEventListener(\"ionBackButton\", (ev) => {\n            ev.detail.register(0, (processNextHandler) => {\n                opts.history.go(-1);\n                processNextHandler();\n            });\n        });\n    }\n    opts.history.listen((_, _x, info) => {\n        /**\n         * history.listen only fires on certain\n         * event such as when the user clicks the\n         * browser back button. It also gives us\n         * additional information as to the type\n         * of navigation (forward, backward, etc).\n         *\n         * We can use this to better handle the\n         * `handleHistoryChange` call in\n         * router.beforeEach\n         */\n        currentNavigationInfo = {\n            delta: info.delta,\n            /**\n             * Both the browser forward and backward actions\n             * are considered \"pop\" actions, but when going forward\n             * we want to make sure the forward animation is used.\n             */\n            action: info.type === \"pop\" && info.delta >= 1 ? \"push\" : info.type,\n            direction: info.direction === \"\" ? \"forward\" : info.direction,\n        };\n    });\n    const handleNavigateBack = (defaultHref, routerAnimation) => {\n        const routeInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n        if (routeInfo && routeInfo.pushedByRoute) {\n            const prevInfo = locationHistory.findLastLocation(routeInfo);\n            if (prevInfo) {\n                incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routerAction: \"pop\", routerDirection: \"back\", routerAnimation: routerAnimation || routeInfo.routerAnimation });\n                if (routeInfo.lastPathname === routeInfo.pushedByRoute ||\n                    /**\n                     * We need to exclude tab switches/tab\n                     * context changes here because tabbed\n                     * navigation is not linear, but router.back()\n                     * will go back in a linear fashion.\n                     */\n                    (prevInfo.pathname === routeInfo.pushedByRoute &&\n                        /**\n                         * Tab info can be undefined or '' (empty string)\n                         * both are false-y values, so we can just use !.\n                         */\n                        !routeInfo.tab &&\n                        !prevInfo.tab)) {\n                    router.back();\n                }\n                else {\n                    /**\n                     * When going back to a child page of a tab\n                     * after being on another tab, we need to use\n                     * router.go() here instead of pushing or replacing.\n                     * Consider the following example:\n                     * /tabs/tab1 --> /tabs/tab1/child1 --> /tabs/tab1/child2\n                     * --> /tabs/tab2 (via Tab 2 button) --> /tabs/tab1/child2 (via Tab 1 button)\n                     *\n                     * Pressing the ion-back-button on /tabs/tab1/child2 should take\n                     * us back to /tabs/tab1/child1 not /tabs/tab2 because each tab\n                     * is its own stack.\n                     *\n                     * If we called pressed the ion-back-button and this code called\n                     * router.replace, then the state of /tabs/tab1/child2 would\n                     * be replaced with /tabs/tab1/child1. However, this means that\n                     * there would be two /tabs/tab1/child1 entries in the location\n                     * history as the original /tabs/tab1/child1 entry is still there.\n                     * As a result, clicking the ion-back-button on /tabs/tab1/child1 does\n                     * nothing because this code would try to route to the same page\n                     * we are currently on.\n                     *\n                     * If we called router.push instead then we would push a\n                     * new /tabs/tab1/child1 entry to the location history. This\n                     * is not good because we would have two /tabs/tab1/child1 entries\n                     * separated by a /tabs/tab1/child2 entry.\n                     */\n                    router.go(prevInfo.position - routeInfo.position);\n                }\n            }\n            else {\n                handleNavigate(defaultHref, \"pop\", \"back\", routerAnimation);\n            }\n        }\n        else {\n            handleNavigate(defaultHref, \"pop\", \"back\", routerAnimation);\n        }\n    };\n    const handleNavigate = (path, routerAction, routerDirection, routerAnimation, tab) => {\n        setIncomingRouteParams(routerAction, routerDirection, routerAnimation, tab);\n        if (routerAction === \"push\") {\n            router.push(path);\n        }\n        else {\n            router.replace(path);\n        }\n    };\n    // TODO RouteLocationNormalized\n    const handleHistoryChange = (location, action, direction, delta) => {\n        let leavingLocationInfo;\n        if (incomingRouteParams) {\n            /**\n             * If we are replacing the state of a route\n             * with another route, the \"leaving\" route\n             * is at the same position in location history\n             * as where the replaced route will exist.\n             */\n            if (incomingRouteParams.routerAction === \"replace\") {\n                leavingLocationInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n            }\n            else if (incomingRouteParams.routerAction === \"pop\") {\n                leavingLocationInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition + 1);\n                /**\n                 * If the Ionic Router action was \"pop\"\n                 * and the browser history action was \"replace\", then\n                 * it is the case that the user clicked an IonBackButton\n                 * that is trying to go back to the route specified\n                 * by the defaultHref property.\n                 *\n                 * The problem is that this route currently does\n                 * not exist in the browser history, and we cannot\n                 * prepend an item in the browser's history stack.\n                 * To work around this, we replace the state of\n                 * the current item instead.\n                 * Given this scenario:\n                 * /page2 --> /page3 --> (back) /page2 --> (defaultHref) /page1\n                 * We would replace the state of /page2 with the state of /page1.\n                 *\n                 * When doing this, we are essentially re-writing past\n                 * history which makes the future history no longer relevant.\n                 * As a result, we clear out the location history so that users\n                 * can begin pushing new routes to the stack.\n                 *\n                 * This pattern is aligned with how the browser handles\n                 * pushing new routes after going back as well as how\n                 * other stack based operations such as undo/redo work.\n                 * For example, if you do tasks A, B, C, undo B and C, and\n                 * then do task D, you cannot \"redo\" B and C because you\n                 * rewrote the stack's past history.\n                 *\n                 * With browser history, it is a similar concept.\n                 * Going /page1 --> /page2 --> /page3 and then doing\n                 * router.go(-2) will bring you back to /page1.\n                 * If you then push /page4, you have rewritten\n                 * the past history and you can no longer go\n                 * forward to /page2 or /page3.\n                 */\n                if (action === \"replace\") {\n                    locationHistory.clearHistory();\n                }\n            }\n            else {\n                /**\n                 * If the routerDirection was specified as \"root\", then\n                 * we are replacing the initial state of location history\n                 * with this incoming route. As a result, the leaving\n                 * history info is stored at the same location as\n                 * where the incoming history location will be stored.\n                 *\n                 * Otherwise, we can assume this is just another route\n                 * that will be pushed onto the end of location history,\n                 * so we can grab the previous item in history relative\n                 * to where the history state currently is.\n                 */\n                const position = incomingRouteParams.routerDirection === \"root\"\n                    ? currentHistoryPosition\n                    : currentHistoryPosition - 1;\n                leavingLocationInfo = locationHistory.current(initialHistoryPosition, position);\n            }\n        }\n        else {\n            leavingLocationInfo = currentRouteInfo;\n        }\n        if (!leavingLocationInfo) {\n            leavingLocationInfo = {\n                pathname: \"\",\n                search: \"\",\n            };\n        }\n        const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n        if (leavingUrl !== location.fullPath) {\n            if (!incomingRouteParams) {\n                if (action === \"replace\") {\n                    incomingRouteParams = {\n                        routerAction: \"replace\",\n                        routerDirection: \"none\",\n                    };\n                }\n                else if (action === \"pop\") {\n                    const routeInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition - delta);\n                    if (routeInfo && routeInfo.pushedByRoute) {\n                        const prevRouteInfo = locationHistory.findLastLocation(routeInfo, delta);\n                        incomingRouteParams = Object.assign(Object.assign({}, prevRouteInfo), { routerAction: \"pop\", routerDirection: \"back\" });\n                    }\n                    else {\n                        incomingRouteParams = {\n                            routerAction: \"pop\",\n                            routerDirection: \"none\",\n                        };\n                    }\n                }\n                if (!incomingRouteParams) {\n                    incomingRouteParams = {\n                        routerAction: \"push\",\n                        routerDirection: direction || \"forward\",\n                    };\n                }\n            }\n            let routeInfo;\n            if (incomingRouteParams === null || incomingRouteParams === void 0 ? void 0 : incomingRouteParams.id) {\n                routeInfo = Object.assign(Object.assign({}, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });\n            }\n            else {\n                const isPushed = incomingRouteParams.routerAction === \"push\" &&\n                    incomingRouteParams.routerDirection === \"forward\";\n                routeInfo = Object.assign(Object.assign({ id: generateId(\"routeInfo\") }, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.path, search: (location.fullPath && location.fullPath.split(\"?\")[1]) || \"\", params: location.params && location.params, prevRouteLastPathname: leavingLocationInfo.lastPathname });\n                if (isPushed) {\n                    routeInfo.pushedByRoute =\n                        leavingLocationInfo.pathname !== \"\"\n                            ? leavingLocationInfo.pathname\n                            : undefined;\n                }\n                else if (routeInfo.routerAction === \"pop\") {\n                    const route = locationHistory.findLastLocation(routeInfo);\n                    routeInfo.pushedByRoute = route === null || route === void 0 ? void 0 : route.pushedByRoute;\n                }\n                else if (routeInfo.routerAction === \"push\" &&\n                    routeInfo.tab !== leavingLocationInfo.tab) {\n                    const lastRoute = locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n                    routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n                }\n                else if (routeInfo.routerAction === \"replace\") {\n                    /**\n                     * When replacing a route, we want to make sure we select the current route\n                     * that we are on, not the last route in the stack. The last route in the stack\n                     * is not always the current route.\n                     * Example:\n                     * Given the following history: /page1 --> /page2\n                     * Doing router.go(-1) would bring you to /page1.\n                     * If you then did router.replace('/page3'), /page1 should\n                     * be replaced with /page3 even though /page2 is the last\n                     * item in the stack/\n                     */\n                    const currentRouteInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n                    /**\n                     * If going from /home to /child, then replacing from\n                     * /child to /home, we don't want the route info to\n                     * say that /home was pushed by /home which is not correct.\n                     */\n                    const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n                    const pushedByRoute = currentPushedBy !== undefined &&\n                        currentPushedBy !== routeInfo.pathname\n                        ? currentPushedBy\n                        : routeInfo.pushedByRoute;\n                    routeInfo.lastPathname =\n                        (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n                    routeInfo.pushedByRoute = pushedByRoute;\n                    routeInfo.routerDirection =\n                        (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerDirection) || routeInfo.routerDirection;\n                    routeInfo.routerAnimation =\n                        (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerAnimation) || routeInfo.routerAnimation;\n                    routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n                }\n            }\n            routeInfo.position = currentHistoryPosition;\n            routeInfo.delta = delta;\n            const historySize = locationHistory.size();\n            const historyDiff = currentHistoryPosition - initialHistoryPosition;\n            /**\n             * If the size of location history is greater\n             * than the difference between the current history\n             * position and the initial history position\n             * then we are guaranteed to already have a history\n             * item for this route. In other words, a user\n             * is navigating within the history without pushing\n             * new items within the stack.\n             *\n             * If the historySize === historyDiff,\n             * then we are still re-writing history\n             * by replacing the current route state\n             * with a new route state. The initial\n             * action when loading an app is\n             * going to be replace operation, so\n             * we want to make sure we exclude that\n             * action by ensuring historySize > 0.\n             */\n            const isReplacing = historySize === historyDiff && historySize > 0 && action === \"replace\";\n            if (historySize > historyDiff || isReplacing) {\n                /**\n                 * When navigating back through the history,\n                 * if users then push a new route the future\n                 * history stack is no longer relevant. As\n                 * a result, we need to clear out all entries\n                 * that appear after the current routeInfo\n                 * so that we can then append the new history.\n                 *\n                 * This does not apply when using router.go\n                 * as that is traversing through the history,\n                 * not altering it.\n                 *\n                 * Previously we had only updated the existing route\n                 * and then left the future history alone. That\n                 * worked for some use cases but was not sufficient\n                 * in other scenarios.\n                 */\n                if ((routeInfo.routerAction === \"push\" ||\n                    routeInfo.routerAction === \"replace\") &&\n                    delta === undefined) {\n                    locationHistory.clearHistory(routeInfo);\n                    locationHistory.add(routeInfo);\n                }\n            }\n            else {\n                locationHistory.add(routeInfo);\n            }\n            /**\n             * If we recently reset the location history\n             * then we also need to update the initial\n             * history position.\n             */\n            if (locationHistory.size() === 1) {\n                initialHistoryPosition = routeInfo.position;\n            }\n            currentRouteInfo = routeInfo;\n        }\n        incomingRouteParams = undefined;\n        historyChangeListeners.forEach((cb) => cb(currentRouteInfo));\n    };\n    const getCurrentRouteInfo = () => currentRouteInfo;\n    const canGoBack = (deep = 1) => locationHistory.canGoBack(deep, initialHistoryPosition, currentHistoryPosition);\n    const navigate = (navigationOptions) => {\n        const { routerAnimation, routerDirection, routerLink } = navigationOptions;\n        setIncomingRouteParams(\"push\", routerDirection, routerAnimation);\n        router.push(routerLink);\n    };\n    const resetTab = (tab) => {\n        /**\n         * Resetting the tab should go back\n         * to the initial view in the tab stack.\n         * It should not push a new instance of the\n         * root tab page onto the stack.\n         *\n         * To do this, we get the initial view in the\n         * tab stack and subtract the position of that\n         * entry from our current position. From there\n         * we call router.go() to move us back the\n         * appropriate number of positions.\n         */\n        const routeInfo = locationHistory.getFirstRouteInfoForTab(tab);\n        if (routeInfo) {\n            router.go(routeInfo.position - currentHistoryPosition);\n        }\n    };\n    const changeTab = (tab, path) => {\n        if (!path)\n            return;\n        const routeInfo = locationHistory.getCurrentRouteInfoForTab(tab);\n        const [pathname] = path.split(\"?\");\n        if (routeInfo) {\n            incomingRouteParams = Object.assign(Object.assign({}, incomingRouteParams), { routerAction: \"push\", routerDirection: \"none\", tab });\n            /**\n             * When going back to a tab\n             * you just left, it's possible\n             * for the route info to be incorrect\n             * as the tab you want is not the\n             * tab you are on.\n             */\n            if (routeInfo.pathname === pathname) {\n                router.push({\n                    path: routeInfo.pathname,\n                    query: parseQuery(routeInfo.search),\n                });\n            }\n            else {\n                router.push({ path: pathname, query: parseQuery(routeInfo.search) });\n            }\n        }\n        else {\n            handleNavigate(pathname, \"push\", \"none\", undefined, tab);\n        }\n    };\n    /**\n     * This method is invoked by the IonTabs component\n     * during a history change callback. It is responsible\n     * for ensuring that tabbed routes have the correct\n     * \"tab\" field in its routeInfo object.\n     *\n     * IonTabs will determine if the current route\n     * is in tabs and assign it the correct tab.\n     * If the current route is not in tabs,\n     * then IonTabs will not invoke this.\n     */\n    const handleSetCurrentTab = (tab) => {\n        /**\n         * Note that the current page that we\n         * are on is not necessarily the last item\n         * in the locationHistory stack. As a result,\n         * we cannot use locationHistory.last() here.\n         */\n        const ri = Object.assign({}, locationHistory.current(initialHistoryPosition, currentHistoryPosition));\n        /**\n         * handleHistoryChange is tabs-agnostic by design.\n         * One side effect of this is that certain tabs\n         * routes have extraneous/incorrect information\n         * that we need to remove. To not tightly couple\n         * handleHistoryChange with tabs, we let the\n         * handleSetCurrentTab function. This function is\n         * only called by IonTabs.\n         */\n        if (ri.tab !== tab) {\n            ri.tab = tab;\n            locationHistory.update(ri);\n        }\n        /**\n         * lastPathname typically equals pushedByRoute\n         * when navigating in a linear manner. When switching between\n         * tabs, this is almost never the case.\n         *\n         * Example: /tabs/tabs1 --> /tabs/tab2 --> /tabs/tab1\n         * The latest Tab 1 route would have the following information\n         * lastPathname: '/tabs/tab2'\n         * pushedByRoute: '/tabs/tab2'\n         *\n         * A tab cannot push another tab, so we need to set\n         * pushedByRoute to `undefined`. Alternative way of thinking\n         * about this: You cannot swipe to go back from Tab 1 to Tab 2.\n         *\n         * However, there are some instances where we do want to keep\n         * the pushedByRoute. As a result, we need to ensure that\n         * we only wipe the pushedByRoute state when the both of the\n         * following conditions are met:\n         * 1. pushedByRoute is different from lastPathname\n         * 2. The tab for the pushedByRoute info is different\n         * from the current route tab.\n         *\n         * Example of when we would not want to clear pushedByRoute:\n         * /tabs/tab1 --> /tabs/tab1/child --> /tabs/tab2 --> /tabs/tab1/child\n         * The latest Tab 1 Child route would have the following information:\n         * lastPathname: '/tabs/tab2'\n         * pushedByRoute: '/tabs/tab1\n         *\n         * In this case, /tabs/tab1/child should be able to swipe to go back\n         * to /tabs/tab1 so we want to keep the pushedByRoute.\n         */\n        const pushedByRoute = locationHistory.findLastLocation(ri);\n        if (ri.pushedByRoute !== ri.lastPathname && (pushedByRoute === null || pushedByRoute === void 0 ? void 0 : pushedByRoute.tab) !== tab) {\n            ri.pushedByRoute = undefined;\n            locationHistory.update(ri);\n        }\n    };\n    const registerHistoryChangeListener = (cb) => {\n        historyChangeListeners.push(cb);\n    };\n    const setIncomingRouteParams = (routerAction = \"push\", routerDirection = \"forward\", routerAnimation, tab) => {\n        incomingRouteParams = {\n            routerAction,\n            routerDirection,\n            routerAnimation,\n            tab,\n        };\n    };\n    const goBack = (routerAnimation) => {\n        setIncomingRouteParams(\"pop\", \"back\", routerAnimation);\n        router.back();\n    };\n    const goForward = (routerAnimation) => {\n        setIncomingRouteParams(\"push\", \"forward\", routerAnimation);\n        router.forward();\n    };\n    const getLeavingRouteInfo = () => {\n        return locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n    };\n    return {\n        handleNavigate,\n        getLeavingRouteInfo,\n        handleNavigateBack,\n        handleSetCurrentTab,\n        getCurrentRouteInfo,\n        canGoBack,\n        navigate,\n        resetTab,\n        changeTab,\n        registerHistoryChangeListener,\n        goBack,\n        goForward,\n    };\n};\n//# sourceMappingURL=router.js.map","import { shallowRef } from \"vue\";\nimport { generateId } from \"./utils\";\nexport const createViewStacks = (router) => {\n    const viewStacks = {};\n    /**\n     * Returns the number of active stacks.\n     * This is useful for determining if an app\n     * is using linear navigation only or non-linear\n     * navigation. Multiple stacks indiciate an app\n     * is using non-linear navigation.\n     */\n    const size = () => Object.keys(viewStacks).length;\n    const clear = (outletId) => {\n        delete viewStacks[outletId];\n    };\n    const getViewStack = (outletId) => {\n        return viewStacks[outletId];\n    };\n    const registerIonPage = (viewItem, ionPage) => {\n        viewItem.ionPageElement = ionPage;\n        viewItem.ionRoute = true;\n        /**\n         * This is needed otherwise Vue Router\n         * will not consider this component mounted\n         * and will not run route guards that\n         * are written in the component.\n         */\n        viewItem.matchedRoute.instances = {\n            default: viewItem.vueComponentRef.value,\n        };\n    };\n    const findViewItemByRouteInfo = (routeInfo, outletId) => {\n        return findViewItemByPath(routeInfo.pathname, outletId, false);\n    };\n    const findLeavingViewItemByRouteInfo = (routeInfo, outletId, mustBeIonRoute = true) => {\n        return findViewItemByPath(routeInfo.lastPathname, outletId, mustBeIonRoute);\n    };\n    const findViewItemByPathname = (pathname, outletId) => {\n        return findViewItemByPath(pathname, outletId, false);\n    };\n    const findViewItemInStack = (path, stack) => {\n        return stack.find((viewItem) => {\n            if (viewItem.pathname === path) {\n                return viewItem;\n            }\n            return undefined;\n        });\n    };\n    const findViewItemByPath = (path, outletId, mustBeIonRoute = false) => {\n        const matchView = (viewItem) => {\n            if ((mustBeIonRoute && !viewItem.ionRoute) || path === \"\") {\n                return false;\n            }\n            const resolvedPath = router.resolve(path);\n            const findMatchedRoute = resolvedPath.matched.find((matchedRoute) => matchedRoute === viewItem.matchedRoute);\n            if (findMatchedRoute) {\n                /**\n                 * /page/1 and /page/2 should not match\n                 * to the same view item otherwise there will\n                 * be not page transition and we will need to\n                 * explicitly clear out parameters from page 1\n                 * so the page 2 params are properly passed\n                 * to the developer's app.\n                 */\n                const hasParameter = findMatchedRoute.path.includes(\":\");\n                if (hasParameter && path !== viewItem.pathname) {\n                    return false;\n                }\n                return viewItem;\n            }\n            return undefined;\n        };\n        if (outletId) {\n            const stack = viewStacks[outletId];\n            if (!stack)\n                return undefined;\n            const match = router\n                ? stack.find(matchView)\n                : findViewItemInStack(path, stack);\n            if (match)\n                return match;\n        }\n        else {\n            for (const outletId in viewStacks) {\n                const stack = viewStacks[outletId];\n                const viewItem = findViewItemInStack(path, stack);\n                if (viewItem) {\n                    return viewItem;\n                }\n            }\n        }\n        return undefined;\n    };\n    // TODO(FW-2969): type\n    const createViewItem = (outletId, vueComponent, matchedRoute, routeInfo, ionPage) => {\n        return {\n            id: generateId(\"viewItem\"),\n            pathname: routeInfo.pathname,\n            outletId,\n            matchedRoute,\n            ionPageElement: ionPage,\n            vueComponent,\n            vueComponentRef: shallowRef(),\n            ionRoute: false,\n            mount: false,\n            exact: routeInfo.pathname === matchedRoute.path,\n            params: routeInfo.params,\n            vueComponentData: {},\n        };\n    };\n    const add = (viewItem) => {\n        const { outletId } = viewItem;\n        if (!viewStacks[outletId]) {\n            viewStacks[outletId] = [viewItem];\n        }\n        else {\n            viewStacks[outletId].push(viewItem);\n        }\n    };\n    const remove = (viewItem, outletId) => {\n        if (!outletId) {\n            throw Error(\"outletId required\");\n        }\n        const viewStack = viewStacks[outletId];\n        if (viewStack) {\n            viewStacks[outletId] = viewStack.filter((item) => item.id !== viewItem.id);\n        }\n    };\n    const getChildrenToRender = (outletId) => {\n        const viewStack = viewStacks[outletId];\n        if (viewStack) {\n            const components = viewStacks[outletId].filter((v) => v.mount);\n            return components;\n        }\n        return [];\n    };\n    /**\n     * When navigating backwards, we need to clean up and\n     * leaving pages so that they are re-created if\n     * we ever navigate back to them. This is especially\n     * important when using router.go and stepping back\n     * multiple pages at a time.\n     */\n    const unmountLeavingViews = (outletId, viewItem, delta = 1) => {\n        const viewStack = viewStacks[outletId];\n        if (!viewStack)\n            return;\n        const startIndex = viewStack.findIndex((v) => v === viewItem);\n        for (let i = startIndex + 1; i < startIndex - delta; i++) {\n            const viewItem = viewStack[i];\n            viewItem.mount = false;\n            viewItem.ionPageElement = undefined;\n            viewItem.ionRoute = false;\n            viewItem.matchedRoute.instances = {};\n        }\n    };\n    /**\n     * When navigating forward it is possible for\n     * developers to step forward over multiple views.\n     * The intermediary views need to be remounted so that\n     * swipe to go back works properly.\n     * We need to account for the delta value here too because\n     * we do not want to remount an unrelated view.\n     * Example:\n     * /home --> /page2 --> router.back() --> /page3\n     * Going to /page3 would remount /page2 since we do\n     * not prune /page2 from the stack. However, /page2\n     * needs to remain in the stack.\n     * Example:\n     * /home --> /page2 --> /page3 --> router.go(-2) --> router.go(2)\n     * We would end up on /page3, but users need to be able to swipe\n     * to go back to /page2 and /home, so we need both pages mounted\n     * in the DOM.\n     */\n    const mountIntermediaryViews = (outletId, viewItem, delta = 1) => {\n        const viewStack = viewStacks[outletId];\n        if (!viewStack)\n            return;\n        const startIndex = viewStack.findIndex((v) => v === viewItem);\n        for (let i = startIndex + 1; i < startIndex + delta; i++) {\n            viewStack[i].mount = true;\n        }\n    };\n    return {\n        unmountLeavingViews,\n        mountIntermediaryViews,\n        clear,\n        findViewItemByRouteInfo,\n        findLeavingViewItemByRouteInfo,\n        findViewItemByPathname,\n        createViewItem,\n        getChildrenToRender,\n        add,\n        remove,\n        registerIonPage,\n        getViewStack,\n        size,\n    };\n};\n//# sourceMappingURL=viewStacks.js.map","import { createRouter as createVueRouter, createWebHistory as createVueWebHistory, createWebHashHistory as createVueWebHashHistory, createMemoryHistory as createVueMemoryHistory, } from \"vue-router\";\nimport { createIonRouter } from \"./router\";\nimport { createViewStacks } from \"./viewStacks\";\nexport const createRouter = (opts) => {\n    const routerOptions = Object.assign({}, opts);\n    delete routerOptions.tabsPrefix;\n    const router = createVueRouter(routerOptions);\n    const ionRouter = createIonRouter(opts, router);\n    const viewStacks = createViewStacks(router);\n    const oldInstall = router.install.bind(router);\n    router.install = (app) => {\n        app.provide(\"navManager\", ionRouter);\n        app.provide(\"viewStacks\", viewStacks);\n        oldInstall(app);\n    };\n    const oldIsReady = router.isReady.bind(router);\n    router.isReady = () => oldIsReady();\n    return router;\n};\nexport const createWebHistory = (base) => createVueWebHistory(base);\nexport const createWebHashHistory = (base) => createVueWebHashHistory(base);\nexport const createMemoryHistory = (base) => createVueMemoryHistory(base);\n//# sourceMappingURL=index.js.map"],"names":["createVueRouter","createVueWebHistory","createVueWebHashHistory","createVueMemoryHistory"],"mappings":"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"}