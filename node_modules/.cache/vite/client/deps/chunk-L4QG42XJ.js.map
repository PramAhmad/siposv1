{
  "version": 3,
  "sources": ["../../../../@supabase/postgrest-js/src/PostgrestBuilder.ts", "../../../../@supabase/postgrest-js/src/PostgrestTransformBuilder.ts", "../../../../@supabase/postgrest-js/src/PostgrestFilterBuilder.ts", "../../../../@supabase/postgrest-js/src/PostgrestQueryBuilder.ts", "../../../../@supabase/postgrest-js/src/version.ts", "../../../../@supabase/postgrest-js/src/constants.ts", "../../../../@supabase/postgrest-js/src/PostgrestClient.ts"],
  "sourcesContent": ["import crossFetch from 'cross-fetch'\n\nimport type { Fetch, PostgrestSingleResponse } from './types'\n\nexport default abstract class PostgrestBuilder<Result>\n  implements PromiseLike<PostgrestSingleResponse<Result>>\n{\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url: URL\n  protected headers: Record<string, string>\n  protected schema?: string\n  protected body?: unknown\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected isMaybeSingle: boolean\n\n  constructor(builder: PostgrestBuilder<Result>) {\n    this.method = builder.method\n    this.url = builder.url\n    this.headers = builder.headers\n    this.schema = builder.schema\n    this.body = builder.body\n    this.shouldThrowOnError = builder.shouldThrowOnError\n    this.signal = builder.signal\n    this.isMaybeSingle = builder.isMaybeSingle\n\n    if (builder.fetch) {\n      this.fetch = builder.fetch\n    } else if (typeof fetch === 'undefined') {\n      this.fetch = crossFetch\n    } else {\n      this.fetch = fetch\n    }\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  then<TResult1 = PostgrestSingleResponse<Result>, TResult2 = never>(\n    onfulfilled?:\n      | ((value: PostgrestSingleResponse<Result>) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema\n    } else {\n      this.headers['Content-Profile'] = this.schema\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json'\n    }\n\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count: number | null = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text()\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = body\n          } else if (\n            this.headers['Accept'] &&\n            this.headers['Accept'].includes('application/vnd.pgrst.plan+text')\n          ) {\n            data = body\n          } else {\n            data = JSON.parse(body)\n          }\n        }\n\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n          if (data.length > 1) {\n            error = {\n              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n              code: 'PGRST116',\n              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n              hint: null,\n              message: 'JSON object requested, multiple (or no) rows returned',\n            }\n            data = null\n            count = null\n            status = 406\n            statusText = 'Not Acceptable'\n          } else if (data.length === 1) {\n            data = data[0]\n          } else {\n            data = null\n          }\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (Array.isArray(error) && res.status === 404) {\n            data = []\n            error = null\n            status = 200\n            statusText = 'OK'\n          }\n        } catch {\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (res.status === 404 && body === '') {\n            status = 204\n            statusText = 'No Content'\n          } else {\n            error = {\n              message: body,\n            }\n          }\n        }\n\n        if (error && this.isMaybeSingle && error?.details?.includes('Results contain 0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw error\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`,\n          details: `${fetchError?.stack ?? ''}`,\n          hint: '',\n          code: `${fetchError?.code ?? ''}`,\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: '',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n}\n", "import PostgrestBuilder from './PostgrestBuilder'\nimport { GetResult } from './select-query-parser'\nimport { GenericSchema } from './types'\n\nexport default class PostgrestTransformBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  Relationships = unknown\n> extends PostgrestBuilder<Result> {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select<Query extends string = '*', NewResultOne = GetResult<Schema, Row, Relationships, Query>>(\n    columns?: Query\n  ): PostgrestTransformBuilder<Schema, Row, NewResultOne[], Relationships> {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (this.headers['Prefer']) {\n      this.headers['Prefer'] += ','\n    }\n    this.headers['Prefer'] += 'return=representation'\n    return this as unknown as PostgrestTransformBuilder<Schema, Row, NewResultOne[], Relationships>\n  }\n\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\n  ): this\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string }\n  ): this\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order foreign tables, but it doesn't affect the ordering of the\n   * current table.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.foreignTable - Set this to order a foreign table by foreign\n   * columns\n   */\n  order(\n    column: string,\n    {\n      ascending = true,\n      nullsFirst,\n      foreignTable,\n    }: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string } = {}\n  ): this {\n    const key = foreignTable ? `${foreignTable}.order` : 'order'\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.foreignTable - Set this to limit rows of foreign tables\n   * instead of the current table\n   */\n  limit(count: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limit the query result by starting at an offset (`from`) and ending at the offset (`from + to`).\n   * Only records within this range are returned.\n   * This respects the query order and if there is no order clause the range could behave unexpectedly.\n   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n   * and fourth rows of the query.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.foreignTable - Set this to limit rows of foreign tables\n   * instead of the current table\n   */\n  range(from: number, to: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\n  >(): PostgrestBuilder<ResultOne> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    return this as PostgrestBuilder<ResultOne>\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\n  >(): PostgrestBuilder<ResultOne | null> {\n    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n    if (this.method === 'GET') {\n      this.headers['Accept'] = 'application/json'\n    } else {\n      this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    }\n    this.isMaybeSingle = true\n    return this as PostgrestBuilder<ResultOne | null>\n  }\n\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv(): PostgrestBuilder<string> {\n    this.headers['Accept'] = 'text/csv'\n    return this as PostgrestBuilder<string>\n  }\n\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson(): PostgrestBuilder<Record<string, unknown>> {\n    this.headers['Accept'] = 'application/geo+json'\n    return this as PostgrestBuilder<Record<string, unknown>>\n  }\n\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text',\n  }: {\n    analyze?: boolean\n    verbose?: boolean\n    settings?: boolean\n    buffers?: boolean\n    wal?: boolean\n    format?: 'json' | 'text'\n  } = {}): PostgrestBuilder<Record<string, unknown>[]> | PostgrestBuilder<string> {\n    const options = [\n      analyze ? 'analyze' : null,\n      verbose ? 'verbose' : null,\n      settings ? 'settings' : null,\n      buffers ? 'buffers' : null,\n      wal ? 'wal' : null,\n    ]\n      .filter(Boolean)\n      .join('|')\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = this.headers['Accept']\n    this.headers[\n      'Accept'\n    ] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\n    if (format === 'json') return this as PostgrestBuilder<Record<string, unknown>[]>\n    else return this as PostgrestBuilder<string>\n  }\n\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback(): this {\n    if ((this.headers['Prefer'] ?? '').trim().length > 0) {\n      this.headers['Prefer'] += ',tx=rollback'\n    } else {\n      this.headers['Prefer'] = 'tx=rollback'\n    }\n    return this\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   */\n  returns<NewResult>(): PostgrestTransformBuilder<Schema, Row, NewResult, Relationships> {\n    return this as unknown as PostgrestTransformBuilder<Schema, Row, NewResult, Relationships>\n  }\n}\n", "import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { GenericSchema } from './types'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n\nexport default class PostgrestFilterBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  Relationships = unknown\n> extends PostgrestTransformBuilder<Schema, Row, Result, Relationships> {\n  eq<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: NonNullable<Row[ColumnName]>\n  ): this\n  eq<Value extends unknown>(column: string, value: NonNullable<Value>): this\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  neq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  neq(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  in<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    values: ReadonlyArray<Row[ColumnName]>\n  ): this\n  in(column: string, values: readonly unknown[]): this\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in(column: string, values: readonly unknown[]): this {\n    const cleanedValues = values\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]>\n  ): this\n  overlaps(column: string, value: string | readonly unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | readonly unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param foreignTable - Set this to filter on foreign tables instead of the\n   * current table\n   */\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = foreignTable ? `${foreignTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n", "import PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser'\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\n\nexport default class PostgrestQueryBuilder<\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView,\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown\n> {\n  url: URL\n  headers: Record<string, string>\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = headers\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<\n    Query extends string = '*',\n    ResultOne = GetResult<Schema, Relation['Row'], Relationships, Query>\n  >(\n    columns?: Query,\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], ResultOne[], Relationships> {\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<ResultOne[]>)\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships>\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships>\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships> {\n    const method = 'POST'\n\n    const prefersHeaders = []\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default')\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships>\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships>\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships> {\n    const method = 'POST'\n\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default')\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships> {\n    const method = 'PATCH'\n    const prefersHeaders = []\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships> {\n    const method = 'DELETE'\n    const prefersHeaders = []\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n}\n", "export const version = '1.8.3'\n", "import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version}` }\n", "import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport { DEFAULT_HEADERS } from './constants'\nimport { Fetch, GenericSchema } from './types'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  url: string\n  headers: Record<string, string>\n  schemaName?: SchemaName\n  fetch?: Fetch\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: SchemaName\n      fetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.schemaName = schema\n    this.fetch = fetch\n  }\n\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View>\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder<Schema, any>(url, {\n      headers: { ...this.headers },\n      schema: this.schemaName,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Database>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return new PostgrestClient<\n      Database,\n      DynamicSchema,\n      Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n    >(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<\n    FunctionName extends string & keyof Schema['Functions'],\n    Function_ extends Schema['Functions'][FunctionName]\n  >(\n    fn: FunctionName,\n    args: Function_['Args'] = {},\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    Schema,\n    Function_['Returns'] extends any[]\n      ? Function_['Returns'][number] extends Record<string, unknown>\n        ? Function_['Returns'][number]\n        : never\n      : never,\n    Function_['Returns']\n  > {\n    let method: 'HEAD' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    if (head) {\n      method = 'HEAD'\n      Object.entries(args).forEach(([name, value]) => {\n        url.searchParams.append(name, `${value}`)\n      })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = { ...this.headers }\n    if (count) {\n      headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<Function_['Returns']>)\n  }\n}\n"],
  "mappings": "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",
  "names": ["crossFetch", "res", "fetch", "fetch"]
}
